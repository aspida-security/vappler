import { supabase } from '../lib/supabase';

export const vulnerabilityService = {

  /**
   * Get all vulnerabilities for a workspace with enriched data
   */
  async getVulnerabilities(workspaceId, filters = {}) {
  try {
    console.log('[vulnerabilityService] Fetching vulnerabilities for workspace:', workspaceId);
    console.log('[vulnerabilityService] Filters:', filters);

    let query = supabase
      .from('vulnerabilities')
      .select('*')
      .eq('workspace_id', workspaceId)
      .order('discovered_at', { ascending: false });

    // Apply filters
    if (filters?.severity && filters.severity !== 'all') {
      query = query.eq('severity', filters.severity);
    }

    if (filters?.status && filters.status !== 'all') {
      query = query.eq('status', filters.status);
    }

    if (filters?.search) {
      query = query.or(`cve_id.ilike.%${filters.search}%,title.ilike.%${filters.search}%,description.ilike.%${filters.search}%`);
    }

    const { data, error } = await query;

    if (error) {
      console.error('[vulnerabilityService] Query error:', error);
      throw error;
    }

    console.log('[vulnerabilityService] Found vulnerabilities:', data?.length || 0);

    // Enrich with asset and scan data
    if (data && data.length > 0) {
      const assetIds = [...new Set(data.map(v => v.asset_id).filter(Boolean))];
      const scanIds = [...new Set(data.map(v => v.scan_id).filter(Boolean))];
      
      console.log('[vulnerabilityService] Asset IDs to fetch:', assetIds.length);
      console.log('[vulnerabilityService] Scan IDs to fetch:', scanIds.length);

      let assetsMap = {};
      let scansMap = {};

      // Fetch assets with CORRECT columns
      if (assetIds.length > 0) {
        try {
          const { data: assetsData, error: assetsError } = await supabase
            .from('assets')
            .select('id, hostname, ip_address, operating_system')  // ✅ FIXED: 'operating_system' not 'os'
            .in('id', assetIds);

          if (assetsError) {
            console.error('[vulnerabilityService] Assets fetch error:', assetsError);
          } else if (assetsData) {
            console.log('[vulnerabilityService] Fetched', assetsData.length, 'assets');
            assetsMap = Object.fromEntries(
              assetsData.map(asset => [asset.id, asset])
            );
          }
        } catch (assetEnrichmentError) {
          console.error('[vulnerabilityService] Asset enrichment failed:', assetEnrichmentError);
        }
      }

      // Fetch scans with CORRECT columns
      if (scanIds.length > 0) {
        try {
          const { data: scansData, error: scansError } = await supabase
            .from('scans')
            .select('id, name, completed_at, scan_type')  // ✅ FIXED: 'name' instead of 'target'
            .in('id', scanIds);

          if (scansError) {
            console.error('[vulnerabilityService] Scans fetch error:', scansError);
          } else if (scansData) {
            console.log('[vulnerabilityService] Fetched', scansData.length, 'scans');
            scansMap = Object.fromEntries(
              scansData.map(scan => [scan.id, scan])
            );
          }
        } catch (scanEnrichmentError) {
          console.error('[vulnerabilityService] Scan enrichment failed:', scanEnrichmentError);
        }
      }

      // Attach related data to vulnerabilities
      const enrichedData = data.map(vuln => ({
        ...vuln,
        asset: assetsMap[vuln.asset_id] || null,
        scan: scansMap[vuln.scan_id] || null
      }));

      console.log('[vulnerabilityService] Enrichment complete. Assets added:', Object.keys(assetsMap).length, 'Scans added:', Object.keys(scansMap).length);
      
      return { data: enrichedData, error: null };
    }

    return { data, error: null };
  } catch (error) {
    console.error('[vulnerabilityService] Error:', error);
    return { data: null, error: error?.message };
  }
},

  /**
   * Get top N vulnerabilities by severity for dashboard display
   * Orders by severity priority (Critical > High > Medium > Low) and CVSS score
   */
  async getTopVulnerabilities(workspaceId, limit = 10) {
    try {
      console.log('[vulnerabilityService] Fetching top vulnerabilities for workspace:', workspaceId, 'limit:', limit);

      // Custom severity ordering: Critical=4, High=3, Medium=2, Low=1
      // We'll fetch all and sort in-memory since Supabase doesn't support CASE-based ordering easily
      const { data, error } = await supabase
        .from('vulnerabilities')
        .select('*')
        .eq('workspace_id', workspaceId)
        .order('cvss_score', { ascending: false }) // Fallback ordering by CVSS
        .limit(limit * 3); // Fetch more than needed to allow custom sorting

      if (error) {
        console.error('[vulnerabilityService] Query error:', error);
        throw error;
      }

      if (!data || data.length === 0) {
        console.log('[vulnerabilityService] No vulnerabilities found');
        return { data: [], error: null };
      }

      // Define severity priority for sorting
      const severityPriority = {
        'Critical': 4,
        'High': 3,
        'Medium': 2,
        'Low': 1,
        'Informational': 0
      };

      // Sort by severity priority (desc) then CVSS score (desc)
      const sortedData = data.sort((a, b) => {
        const severityDiff = (severityPriority[b.severity] || 0) - (severityPriority[a.severity] || 0);
        if (severityDiff !== 0) return severityDiff;
        return (b.cvss_score || 0) - (a.cvss_score || 0);
      }).slice(0, limit); // Take only the top N after sorting

      // Enrich with asset data
      const assetIds = [...new Set(sortedData.map(v => v.asset_id).filter(Boolean))];
      let assetsMap = {};

      if (assetIds.length > 0) {
        const { data: assetsData } = await supabase
          .from('assets')
          .select('id, hostname, ip_address, operating_system')
          .in('id', assetIds);

        if (assetsData) {
          assetsMap = Object.fromEntries(
            assetsData.map(asset => [asset.id, asset])
          );
        }
      }

      // Attach asset data to vulnerabilities
      const enrichedData = sortedData.map(vuln => ({
        ...vuln,
        assets: assetsMap[vuln.asset_id] || null
      }));

      console.log('[vulnerabilityService] Returning top', enrichedData.length, 'vulnerabilities');
      return { data: enrichedData, error: null };

    } catch (error) {
      console.error('[vulnerabilityService] getTopVulnerabilities error:', error);
      return { data: null, error: error?.message };
    }
  },

  /**
   * Get vulnerability statistics for a workspace
   */
  async getVulnerabilityStats(workspaceId) {
    try {
      const { data, error } = await supabase
        .from('vulnerabilities')
        .select('severity, status')
        .eq('workspace_id', workspaceId);

      if (error) throw error;

      const stats = {
        total: data?.length || 0,
        critical: data?.filter(v => v?.severity === 'Critical')?.length || 0,
        high: data?.filter(v => v?.severity === 'High')?.length || 0,
        medium: data?.filter(v => v?.severity === 'Medium')?.length || 0,
        low: data?.filter(v => v?.severity === 'Low')?.length || 0,
        open: data?.filter(v => v?.status === 'open')?.length || 0,
        resolved: data?.filter(v => v?.status === 'resolved')?.length || 0,
        inProgress: data?.filter(v => v?.status === 'in_progress')?.length || 0,
      };

      return { data: stats, error: null };
    } catch (error) {
      return { data: null, error: error?.message };
    }
  },

  /**
   * Update vulnerability status
   */
  async updateVulnerabilityStatus(id, status) {
    try {
      console.log('[vulnerabilityService] Updating status:', id, status);

      const { data, error } = await supabase
        .from('vulnerabilities')
        .update({
          status,
          updated_at: new Date().toISOString()
        })
        .eq('id', id)
        .select()
        .single();

      if (error) throw error;

      console.log('[vulnerabilityService] Status updated successfully');
      return { data, error: null };
    } catch (error) {
      console.error('[vulnerabilityService] Update error:', error);
      return { data: null, error: error.message };
    }
  },

  /**
   * Delete a vulnerability
   */
  async deleteVulnerability(id) {
    try {
      console.log('[vulnerabilityService] Deleting vulnerability:', id);

      const { error } = await supabase
        .from('vulnerabilities')
        .delete()
        .eq('id', id);

      if (error) throw error;

      console.log('[vulnerabilityService] Vulnerability deleted successfully');
      return { error: null };
    } catch (error) {
      console.error('[vulnerabilityService] Delete error:', error);
      return { error: error.message };
    }
  },

  /**
   * Get a single vulnerability by ID
   */
  async getVulnerabilityById(id) {
    try {
      const { data, error } = await supabase
        .from('vulnerabilities')
        .select('*')
        .eq('id', id)
        .single();

      if (error) throw error;

      // Enrich with asset data
      if (data && data.asset_id) {
        const { data: asset } = await supabase
          .from('assets')
           .select('id, hostname, ip_address, operating_system')
          .eq('id', data.asset_id)
          .single();

        data.assets = asset;
      }

      return { data, error: null };
    } catch (error) {
      return { data: null, error: error.message };
    }
  },

  /**
   * Bulk update vulnerabilities
   */
  async bulkUpdateStatus(ids, status) {
    try {
      console.log('[vulnerabilityService] Bulk updating:', ids.length, 'vulnerabilities to', status);

      const { data, error } = await supabase
        .from('vulnerabilities')
        .update({
          status,
          updated_at: new Date().toISOString()
        })
        .in('id', ids)
        .select();

      if (error) throw error;

      console.log('[vulnerabilityService] Bulk update successful');
      return { data, error: null };
    } catch (error) {
      console.error('[vulnerabilityService] Bulk update error:', error);
      return { data: null, error: error.message };
    }
  },

  /**
   * Bulk delete vulnerabilities
   */
  async bulkDelete(ids) {
    try {
      console.log('[vulnerabilityService] Bulk deleting:', ids.length, 'vulnerabilities');

      const { error } = await supabase
        .from('vulnerabilities')
        .delete()
        .in('id', ids);

      if (error) throw error;

      console.log('[vulnerabilityService] Bulk delete successful');
      return { error: null };
    } catch (error) {
      console.error('[vulnerabilityService] Bulk delete error:', error);
      return { error: error.message };
    }
  },

};
