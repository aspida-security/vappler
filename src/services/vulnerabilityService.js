import { supabase } from '../lib/supabase';

export const vulnerabilityService = {
  // Get all vulnerabilities for a workspace
  async getVulnerabilities(workspaceId, filters = {}) {
    try {
      let query = supabase
        ?.from('vulnerabilities')
        ?.select(`
          *,
          assets:asset_id(hostname, ip_address, operating_system),
          scans:scan_id(name, completed_at)
        `)
        ?.eq('workspace_id', workspaceId)
        ?.order('discovered_at', { ascending: false });

      // Apply filters
      if (filters?.severity) {
        query = query?.eq('severity', filters?.severity);
      }
      
      if (filters?.status) {
        query = query?.eq('status', filters?.status);
      }
      
      if (filters?.cve_id) {
        query = query?.ilike('cve_id', `%${filters?.cve_id}%`);
      }

      const { data, error } = await query;
      
      if (error) {
        throw error;
      }
      
      return { data, error: null };
    } catch (error) {
      return { data: null, error: error?.message };
    }
  },

  // Get top vulnerabilities by severity
  async getTopVulnerabilities(workspaceId, limit = 10) {
    try {
      const { data, error } = await supabase
        ?.from('vulnerabilities')
        ?.select(`
          *,
          assets:asset_id(hostname, ip_address, operating_system)
        `)
        ?.eq('workspace_id', workspaceId)
        ?.eq('status', 'open')
        ?.order('cvss_score', { ascending: false })
        ?.limit(limit);
      
      if (error) {
        throw error;
      }
      
      return { data, error: null };
    } catch (error) {
      return { data: null, error: error?.message };
    }
  },

  // Get vulnerability statistics
  async getVulnerabilityStats(workspaceId) {
    try {
      const { data, error } = await supabase
        ?.from('vulnerabilities')
        ?.select('severity, status')
        ?.eq('workspace_id', workspaceId);
      
      if (error) {
        throw error;
      }
      
      const stats = {
        total: data?.length || 0,
        critical: data?.filter(v => v?.severity === 'Critical')?.length || 0,
        high: data?.filter(v => v?.severity === 'High')?.length || 0,
        medium: data?.filter(v => v?.severity === 'Medium')?.length || 0,
        low: data?.filter(v => v?.severity === 'Low')?.length || 0,
        open: data?.filter(v => v?.status === 'open')?.length || 0,
        confirmed: data?.filter(v => v?.status === 'confirmed')?.length || 0,
        remediated: data?.filter(v => v?.status === 'remediated')?.length || 0
      };
      
      return { data: stats, error: null };
    } catch (error) {
      return { data: null, error: error?.message };
    }
  },

  // Get single vulnerability
  async getVulnerability(id) {
    try {
      const { data, error } = await supabase
        ?.from('vulnerabilities')
        ?.select(`
          *,
          assets:asset_id(hostname, ip_address, operating_system, asset_type),
          scans:scan_id(name, completed_at),
          workspaces:workspace_id(name)
        `)
        ?.eq('id', id)
        ?.single();
      
      if (error) {
        throw error;
      }
      
      return { data, error: null };
    } catch (error) {
      return { data: null, error: error?.message };
    }
  },

  // Update vulnerability status
  async updateVulnerabilityStatus(id, status, notes = '') {
    try {
      const { data, error } = await supabase
        ?.from('vulnerabilities')
        ?.update({ 
          status, 
          updated_at: new Date()?.toISOString(),
          ...(notes && { notes })
        })
        ?.eq('id', id)
        ?.select()
        ?.single();
      
      if (error) {
        throw error;
      }
      
      return { data, error: null };
    } catch (error) {
      return { data: null, error: error?.message };
    }
  },

  // Create new vulnerability
  async createVulnerability(vulnerabilityData) {
    try {
      const { data, error } = await supabase
        ?.from('vulnerabilities')
        ?.insert([{
          ...vulnerabilityData,
          discovered_at: new Date()?.toISOString()
        }])
        ?.select()
        ?.single();
      
      if (error) {
        throw error;
      }
      
      return { data, error: null };
    } catch (error) {
      return { data: null, error: error?.message };
    }
  },

  // Delete vulnerability
  async deleteVulnerability(id) {
    try {
      const { error } = await supabase
        ?.from('vulnerabilities')
        ?.delete()
        ?.eq('id', id);
      
      if (error) {
        throw error;
      }
      
      return { error: null };
    } catch (error) {
      return { error: error?.message };
    }
  }
};